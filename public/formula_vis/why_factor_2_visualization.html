<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸ºä»€ä¹ˆå‡ ä½•å› å­æ˜¯2ï¼Ÿ- ç»ˆæ3Då¯è§†åŒ–</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #001122, #000000);
            font-family: 'Arial', sans-serif;
            color: #ffffff;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 10, 30, 0.95);
            border: 2px solid;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
            z-index: 100;
        }
        
        #step-panel {
            top: 20px;
            left: 20px;
            width: 380px;
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        
        #calculation-panel {
            top: 20px;
            right: 20px;
            width: 350px;
            border-color: #ff6b35;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.3);
        }
        
        #controls-panel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            border-color: #ff00ff;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        .step-title {
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .step-content {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .highlight {
            color: #ffff00;
            font-weight: bold;
            text-shadow: 0 0 8px #ffff00;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            margin: 10px 0;
            border-left: 4px solid #00ff00;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #ffff00);
            border-radius: 4px;
            transition: width 0.5s ease;
            width: 0%;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 10px;
        }
        
        .control-group label {
            color: #ffffff;
            margin-bottom: 8px;
            font-size: 12px;
            text-align: center;
        }
        
        input[type="range"] {
            width: 100px;
            margin: 5px 0;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            border: none;
            color: white;
            padding: 12px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin: 0 5px;
            font-size: 12px;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.6);
        }
        
        button.active {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        }
        
        .fountain-mode {
            border-color: #00ffff !important;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5) !important;
        }
        
        .hemisphere-mode {
            border-color: #ffff00 !important;
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.5) !important;
        }
        
        .projection-mode {
            border-color: #ff00ff !important;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5) !important;
        }
        
        .factor-mode {
            border-color: #00ff00 !important;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5) !important;
        }
        
        #big-number {
            font-size: 48px;
            font-weight: bold;
            color: #00ff00;
            text-align: center;
            text-shadow: 0 0 20px #00ff00;
            margin: 20px 0;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        
        .error-highlight {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
            padding: 5px;
            border-radius: 4px;
            text-shadow: 0 0 10px #ff4444;
        }
        
        .correct-highlight {
            color: #44ff44;
            background: rgba(68, 255, 68, 0.2);
            padding: 5px;
            border-radius: 4px;
            text-shadow: 0 0 10px #44ff44;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #00ffff;
            z-index: 200;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="loading" id="loading">æ­£åœ¨æ„å»º3Då‡ ä½•è¯æ˜...</div>
    
    <div id="container">
        <!-- æ­¥éª¤è§£é‡Šé¢æ¿ -->
        <div id="step-panel" class="ui-panel fountain-mode">
            <div class="step-title">ğŸ¯ å–·æ³‰æ¯”å–»ç†è§£</div>
            <div class="step-content">
                <div class="highlight">å½“å‰é˜¶æ®µï¼š</div>
                <div id="current-step">æ­¥éª¤1ï¼šç©ºé—´å‘æ•£å¯è§†åŒ–</div>
                
                <div class="highlight">æ ¸å¿ƒæ¦‚å¿µï¼š</div>
                <div id="concept-text">
                    Mâ‚åƒå–·æ³‰ä¸€æ ·å‘å››å‘¨å–·å°„"ç©ºé—´ä½œç”¨"<br>
                    åªæœ‰å°„å‘Mâ‚‚æ–¹å‘çš„"æ°´èŠ±"æ‰æœ‰æ•ˆ
                </div>
                
                <div class="highlight">è§‚å¯Ÿè¦ç‚¹ï¼š</div>
                <div id="observation-text">
                    â€¢ è“è‰²ç²’å­ï¼šå…¨æ–¹å‘å‘æ•£<br>
                    â€¢ çº¢è‰²åŒºåŸŸï¼šæœ‰æ•ˆä½œç”¨åŒº<br>
                    â€¢ æ³¨æ„è§’åº¦Î¸çš„å˜åŒ–æ•ˆåº”
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="step-progress"></div>
                </div>
            </div>
        </div>
        
        <!-- è®¡ç®—é¢æ¿ -->
        <div id="calculation-panel" class="ui-panel fountain-mode">
            <div class="step-title">ğŸ“Š å®æ—¶è®¡ç®—</div>
            
            <div class="math-formula">
                <div>çƒé¢æ€»é¢ç§¯ï¼š<span class="highlight">4Ï€</span></div>
                <div>åŠçƒé¢ç§¯ï¼š<span class="highlight" id="hemisphere-area">2Ï€</span></div>
                <div>æœ‰æ•ˆæ¯”ä¾‹ï¼š<span id="ratio-value">1/2</span></div>
            </div>
            
            <div class="math-formula">
                <div>sinÂ²Î¸ ç§¯åˆ†ï¼š<span id="sin2-integral">Ï€/2</span></div>
                <div>å‚è€ƒç§¯åˆ†ï¼š<span id="reference-integral">Ï€</span></div>
                <div>æ•ˆæœæ¯”ä¾‹ï¼š<span id="effect-ratio">1/2</span></div>
            </div>
            
            <div id="big-number">2</div>
            
            <div class="math-formula">
                <div class="correct-highlight">
                    å‡ ä½•å› å­ = 1 Ã· æ•ˆæœæ¯”ä¾‹<br>
                    = 1 Ã· (1/2) = <span class="highlight">2</span>
                </div>
            </div>
            
            <div style="margin-top: 15px; font-size: 12px; color: #aaaaaa;">
                å®æ—¶æ•°å€¼ï¼šÎ¸=<span id="theta-display">0Â°</span>,
                sinÂ²Î¸=<span id="sin2-display">0.000</span>
            </div>
        </div>
        
        <!-- æ§åˆ¶é¢æ¿ -->
        <div id="controls-panel" class="ui-panel fountain-mode">
            <div class="control-group">
                <label>æ¼”ç¤ºæ­¥éª¤</label>
                <button onclick="setStep(1)" id="step1-btn" class="active">1.å–·æ³‰å‘æ•£</button>
                <button onclick="setStep(2)" id="step2-btn">2.åŠçƒç­›é€‰</button>
                <button onclick="setStep(3)" id="step3-btn">3.æŠ•å½±æƒé‡</button>
                <button onclick="setStep(4)" id="step4-btn">4.å› å­æ¨å¯¼</button>
            </div>
            
            <div class="control-group">
                <label>åŠ¨ç”»æ§åˆ¶</label>
                <button onclick="toggleAnimation()" id="anim-btn">æš‚åœ</button>
                <button onclick="resetDemo()">é‡ç½®</button>
                <input type="range" id="speed-slider" min="0.1" max="3" step="0.1" value="1">
                <label>é€Ÿåº¦</label>
            </div>
            
            <div class="control-group">
                <label>ç²’å­æ•°é‡</label>
                <input type="range" id="particle-count" min="200" max="2000" step="100" value="800">
                <button onclick="updateParticles()">æ›´æ–°</button>
            </div>
            
            <div class="control-group">
                <label>è§†è§’æ§åˆ¶</label>
                <button onclick="resetCamera()">é‡ç½®è§†è§’</button>
                <button onclick="toggleProjection()">åˆ‡æ¢æŠ•å½±</button>
            </div>
            
            <div class="control-group">
                <label>é”™è¯¯å¯¹æ¯”</label>
                <button onclick="showWrongMethod()" id="wrong-btn">é”™è¯¯æ–¹æ³•</button>
                <button onclick="showCorrectMethod()" id="correct-btn" class="active">æ­£ç¡®æ–¹æ³•</button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let fountain, hemisphere, projectionPlane, factorVisualization;
        let particles = [];
        let animationId;
        let isAnimating = true;
        let currentStep = 1;
        let time = 0;
        let animationSpeed = 1;
        let particleCount = 800;
        
        // ç‰©ç†å¯¹è±¡
        let massM1, massM2;
        let connectionLine;
        let coordinateAxes;
        
        // æ¼”ç¤ºæ•°æ®
        let stepData = {
            progress: 0,
            hemisphereRatio: 0.5,
            sin2Integral: Math.PI / 2,
            effectRatio: 0.5,
            geometricFactor: 2
        };
        
        // åˆå§‹åŒ–
        function init() {
            setupScene();
            createGeometry();
            createParticleSystem();
            setupLighting();
            setupEventListeners();
            
            document.getElementById('loading').style.display = 'none';
            animate();
        }
        
        function setupScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x001122, 30, 150);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(40, 25, 40);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x001122, 0.9);
            
            document.getElementById('container').appendChild(renderer.domElement);
        }
        
        function createGeometry() {
            // è´¨é‡ä½“ M1 (å–·æ³‰æº)
            const m1Geometry = new THREE.SphereGeometry(3, 32, 32);
            const m1Material = new THREE.MeshPhongMaterial({
                color: 0xff6b35,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            massM1 = new THREE.Mesh(m1Geometry, m1Material);
            massM1.position.set(-20, 0, 0);
            massM1.castShadow = true;
            scene.add(massM1);
            
            // è´¨é‡ä½“ M2 (ç›®æ ‡)
            const m2Geometry = new THREE.SphereGeometry(2, 32, 32);
            const m2Material = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            massM2 = new THREE.Mesh(m2Geometry, m2Material);
            massM2.position.set(20, 0, 0);
            massM2.castShadow = true;
            scene.add(massM2);
            
            // è¿æ¥çº¿
            const linePoints = [massM1.position.clone(), massM2.position.clone()];
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6 
            });
            connectionLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(connectionLine);
            
            // çƒé¢ç½‘æ ¼ (4Ï€ æ€»ç©ºé—´)
            const sphereGeometry = new THREE.SphereGeometry(25, 32, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x444444,
                transparent: true,
                opacity: 0.15,
                wireframe: true
            });
            const totalSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            totalSphere.position.copy(massM1.position);
            scene.add(totalSphere);
            
            // åŠçƒé¢ (2Ï€ æœ‰æ•ˆç©ºé—´)
            const hemisphereGeometry = new THREE.SphereGeometry(25, 32, 16, 0, Math.PI);
            const hemisphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            hemisphere = new THREE.Mesh(hemisphereGeometry, hemisphereMaterial);
            hemisphere.position.copy(massM1.position);
            hemisphere.rotation.y = 0; // æœå‘M2
            hemisphere.visible = false;
            scene.add(hemisphere);
            
            // æŠ•å½±å¹³é¢
            const planeGeometry = new THREE.PlaneGeometry(40, 40, 20, 20);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide,
                wireframe: true
            });
            projectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            projectionPlane.rotation.y = Math.PI / 2;
            projectionPlane.position.set(0, 0, 0);
            projectionPlane.visible = false;
            scene.add(projectionPlane);
            
            // åæ ‡è½´
            coordinateAxes = new THREE.Group();
            
            // Xè½´ (è¿æ¥æ–¹å‘)
            const xAxis = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0), 
                new THREE.Vector3(-30, 0, 0), 
                60, 
                0xff0000, 
                8, 3
            );
            coordinateAxes.add(xAxis);
            
            // Yè½´
            const yAxis = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0), 
                new THREE.Vector3(0, -30, 0), 
                60, 
                0x00ff00, 
                8, 3
            );
            coordinateAxes.add(yAxis);
            
            // Zè½´
            const zAxis = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1), 
                new THREE.Vector3(0, 0, -30), 
                60, 
                0x0000ff, 
                8, 3
            );
            coordinateAxes.add(zAxis);
            
            scene.add(coordinateAxes);
        }
        
        function createParticleSystem() {
            // æ¸…é™¤æ—§ç²’å­
            particles.forEach(particle => scene.remove(particle));
            particles = [];
            
            const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            
            for (let i = 0; i < particleCount; i++) {
                // çƒé¢å‡åŒ€åˆ†å¸ƒ
                const u = Math.random();
                const v = Math.random();
                const phi = 2 * Math.PI * u; // æ–¹ä½è§’
                const theta = Math.acos(2 * v - 1); // æè§’
                
                // è®¡ç®—é¢œè‰²åŸºäº sinÂ²Î¸
                const sinTheta = Math.sin(theta);
                const sin2Theta = sinTheta * sinTheta;
                
                const particleMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(
                        0.6 - sin2Theta * 0.4, // è‰²è°ƒï¼šé’è‰²åˆ°ç´«è‰²
                        0.8 + sin2Theta * 0.2,  // é¥±å’Œåº¦
                        0.4 + sin2Theta * 0.4   // äº®åº¦
                    ),
                    transparent: true,
                    opacity: 0.7
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // åˆå§‹ä½ç½®åœ¨ M1 é™„è¿‘
                particle.position.copy(massM1.position);
                particle.position.add(new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                ));
                
                // å­˜å‚¨å‘å°„æ–¹å‘å’Œç‰©ç†å‚æ•°
                particle.userData = {
                    direction: new THREE.Vector3(
                        Math.sin(theta) * Math.cos(phi),
                        Math.sin(theta) * Math.sin(phi),
                        Math.cos(theta)
                    ),
                    theta: theta,
                    phi: phi,
                    sin2Theta: sin2Theta,
                    speed: 0.3 + Math.random() * 0.2,
                    startTime: Math.random() * Math.PI * 2,
                    originalOpacity: 0.7
                };
                
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function setupLighting() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // M1 çš„å…‰æº
            const m1Light = new THREE.PointLight(0xff6b35, 2, 60);
            m1Light.position.copy(massM1.position);
            scene.add(m1Light);
            
            // M2 çš„å…‰æº  
            const m2Light = new THREE.PointLight(0x00ffff, 1, 40);
            m2Light.position.copy(massM2.position);
            scene.add(m2Light);
        }
        
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            
            // æ»‘å—äº‹ä»¶
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
            });
            
            document.getElementById('particle-count').addEventListener('input', (e) => {
                particleCount = parseInt(e.target.value);
            });
            
            // é¼ æ ‡æ§åˆ¶
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            document.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            // æ»šè½®ç¼©æ”¾
            renderer.domElement.addEventListener('wheel', (e) => {
                const scaleFactor = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scaleFactor);
                camera.position.clampLength(15, 120);
            });
        }
        
        function animate() {
            if (isAnimating) {
                time += 0.016 * animationSpeed;
                updateParticleAnimation();
                updateStepAnimation();
                updateUI();
                updateMassAnimation();
            }
            
            renderer.render(scene, camera);
            animationId = requestAnimationFrame(animate);
        }
        
        function updateParticleAnimation() {
            const radius = 25;
            
            particles.forEach((particle, index) => {
                const userData = particle.userData;
                const t = time + userData.startTime;
                
                // æ ¹æ®å½“å‰æ­¥éª¤è°ƒæ•´ç²’å­è¡Œä¸º
                switch(currentStep) {
                    case 1: // å–·æ³‰å‘æ•£
                        updateFountainMode(particle, t, radius);
                        break;
                    case 2: // åŠçƒç­›é€‰
                        updateHemisphereMode(particle, t, radius);
                        break;
                    case 3: // æŠ•å½±æƒé‡
                        updateProjectionMode(particle, t, radius);
                        break;
                    case 4: // å› å­æ¨å¯¼
                        updateFactorMode(particle, t, radius);
                        break;
                }
            });
        }
        
        function updateFountainMode(particle, t, radius) {
            const userData = particle.userData;
            const cycleTime = t * userData.speed;
            const distance = (Math.sin(cycleTime) * 0.5 + 0.5) * radius;
            
            // ä»M1å‘å¤–å‘æ•£
            const pos = massM1.position.clone();
            pos.add(userData.direction.clone().multiplyScalar(distance));
            particle.position.copy(pos);
            
            // é€æ˜åº¦åŸºäºè·ç¦»
            const alpha = userData.originalOpacity * (1 - distance / radius);
            particle.material.opacity = alpha;
            
            // å¤§å°å˜åŒ–
            const scale = 1 + Math.sin(cycleTime * 2) * 0.3;
            particle.scale.setScalar(scale);
        }
        
        function updateHemisphereMode(particle, t, radius) {
            const userData = particle.userData;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨æœå‘M2çš„åŠçƒå†…
            const dirToM2 = massM2.position.clone().sub(massM1.position).normalize();
            const isTowardM2 = userData.direction.dot(dirToM2) > 0;
            
            if (isTowardM2) {
                // æœ‰æ•ˆç²’å­ï¼šæ­£å¸¸æ˜¾ç¤º
                updateFountainMode(particle, t, radius);
                particle.material.opacity *= 1.5; // å¢å¼ºæ˜¾ç¤º
                particle.material.color.setHex(0x00ff00); // ç»¿è‰²è¡¨ç¤ºæœ‰æ•ˆ
            } else {
                // æ— æ•ˆç²’å­ï¼šæ·¡åŒ–
                updateFountainMode(particle, t, radius);
                particle.material.opacity *= 0.2; // å¤§å¹…æ·¡åŒ–
                particle.material.color.setHex(0x666666); // ç°è‰²è¡¨ç¤ºæ— æ•ˆ
            }
        }
        
        function updateProjectionMode(particle, t, radius) {
            const userData = particle.userData;
            const dirToM2 = massM2.position.clone().sub(massM1.position).normalize();
            const isTowardM2 = userData.direction.dot(dirToM2) > 0;
            
            if (isTowardM2) {
                updateFountainMode(particle, t, radius);
                
                // åŸºäº sinÂ²Î¸ è°ƒæ•´æ˜¾ç¤º
                const intensity = userData.sin2Theta;
                particle.material.opacity = userData.originalOpacity * intensity * 2;
                
                // é¢œè‰²åŸºäº sinÂ²Î¸ï¼šçº¢è‰²(ä½) -> é»„è‰²(ä¸­) -> ç»¿è‰²(é«˜)
                particle.material.color.setHSL(
                    intensity * 0.33, // 0=çº¢è‰², 0.33=ç»¿è‰²
                    1.0,
                    0.5 + intensity * 0.3
                );
                
                // å¤§å°åŸºäºæƒé‡
                particle.scale.setScalar(0.5 + intensity * 1.5);
            } else {
                particle.material.opacity = 0.05;
            }
        }
        
        function updateFactorMode(particle, t, radius) {
            updateProjectionMode(particle, t, radius);
            
            // æ·»åŠ å‡ ä½•å› å­çš„å¯è§†åŒ–æ•ˆæœ
            const userData = particle.userData;
            const dirToM2 = massM2.position.clone().sub(massM1.position).normalize();
            const isTowardM2 = userData.direction.dot(dirToM2) > 0;
            
            if (isTowardM2 && userData.sin2Theta > 0.1) {
                // é«˜æƒé‡ç²’å­æ˜¾ç¤º"Ã—2"æ•ˆæœ
                const pulseFactor = 1 + Math.sin(t * 4) * 0.5;
                particle.scale.multiplyScalar(pulseFactor);
                
                // æ·»åŠ è¾‰å…‰æ•ˆæœ
                if (userData.sin2Theta > 0.7) {
                    particle.material.emissive.setHex(0x004400);
                }
            }
        }
        
        function updateStepAnimation() {
            // æ›´æ–°æ­¥éª¤è¿›åº¦
            stepData.progress = (Math.sin(time * 0.5) + 1) * 0.5;
            
            // æ ¹æ®æ­¥éª¤æ˜¾ç¤º/éšè—å‡ ä½•ä½“
            switch(currentStep) {
                case 1:
                    hemisphere.visible = false;
                    projectionPlane.visible = false;
                    break;
                case 2:
                    hemisphere.visible = true;
                    projectionPlane.visible = false;
                    hemisphere.material.opacity = 0.3 + stepData.progress * 0.3;
                    break;
                case 3:
                    hemisphere.visible = true;
                    projectionPlane.visible = true;
                    projectionPlane.material.opacity = 0.2 + stepData.progress * 0.3;
                    break;
                case 4:
                    hemisphere.visible = true;
                    projectionPlane.visible = true;
                    
                    // å‡ ä½•å› å­å¯è§†åŒ–ï¼šæ˜¾ç¤ºå€å¢æ•ˆåº”
                    const factorGlow = 0.5 + stepData.progress * 0.5;
                    hemisphere.material.emissive.setHex(0x002200);
                    projectionPlane.material.emissive.setHex(0x220022);
                    break;
            }
        }
        
        function updateUI() {
            // æ›´æ–°è¿›åº¦æ¡
            document.getElementById('step-progress').style.width = (stepData.progress * 100) + '%';
            
            // æ›´æ–°å®æ—¶æ•°å€¼
            const currentTheta = stepData.progress * Math.PI;
            const sin2Value = Math.sin(currentTheta) * Math.sin(currentTheta);
            
            document.getElementById('theta-display').textContent = (currentTheta * 180 / Math.PI).toFixed(1) + 'Â°';
            document.getElementById('sin2-display').textContent = sin2Value.toFixed(3);
            
            // æ›´æ–°è®¡ç®—é¢æ¿æ•°å€¼
            document.getElementById('hemisphere-area').textContent = '2Ï€';
            document.getElementById('ratio-value').textContent = '1/2';
            document.getElementById('sin2-integral').textContent = 'Ï€/2';
            document.getElementById('reference-integral').textContent = 'Ï€';
            document.getElementById('effect-ratio').textContent = '1/2';
        }
        
        function updateMassAnimation() {
            // è´¨é‡ä½“è½»å¾®åŠ¨ç”»
            massM1.position.y = Math.sin(time * 1.5) * 0.8;
            massM1.rotation.y += 0.01 * animationSpeed;
            
            massM2.position.y = Math.cos(time * 1.2) * 0.6;
            massM2.rotation.x += 0.012 * animationSpeed;
            
            // è¿æ¥çº¿è·Ÿéš
            const linePoints = [massM1.position.clone(), massM2.position.clone()];
            connectionLine.geometry.setFromPoints(linePoints);
        }
        
        // æ§åˆ¶å‡½æ•°
        function setStep(step) {
            currentStep = step;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('#controls-panel button[id*="step"]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`step${step}-btn`).classList.add('active');
            
            // æ›´æ–°é¢æ¿æ ·å¼å’Œå†…å®¹
            const panels = document.querySelectorAll('.ui-panel');
            panels.forEach(panel => {
                panel.className = 'ui-panel'; // é‡ç½®ç±»å
            });
            
            switch(step) {
                case 1:
                    panels.forEach(panel => panel.classList.add('fountain-mode'));
                    updateStepContent(
                        'ğŸ¯ å–·æ³‰å‘æ•£æ¨¡å¼',
                        'æ­¥éª¤1ï¼šè§‚å¯Ÿç©ºé—´å‘å››å‘¨å‘æ•£',
                        'Mâ‚åƒå–·æ³‰ä¸€æ ·å‘å…¨ç©ºé—´4Ï€æ–¹å‘å‘å°„"ä½œç”¨"<br>æ¯ä¸ªè“è‰²ç²’å­ä»£è¡¨ä¸€ä¸ªå‘æ•£æ–¹å‘',
                        'â€¢ è“è‰²ç²’å­ï¼šå…¨æ–¹å‘å‘æ•£<br>â€¢ å‘æ•£é€Ÿåº¦ï¼šå…‰é€Ÿc<br>â€¢ æ³¨æ„çƒå¯¹ç§°åˆ†å¸ƒ'
                    );
                    break;
                    
                case 2:
                    panels.forEach(panel => panel.classList.add('hemisphere-mode'));
                    updateStepContent(
                        'ğŸŒ— åŠçƒç­›é€‰æ¨¡å¼',  
                        'æ­¥éª¤2ï¼šç­›é€‰æœå‘Mâ‚‚çš„åŠçƒ',
                        'åªæœ‰æœå‘Mâ‚‚æ–¹å‘çš„"ä½œç”¨"æ‰æœ‰æ•ˆ<br>æœ‰æ•ˆç©ºé—´ï¼š2Ï€ï¼ˆåŠçƒï¼‰vs æ€»ç©ºé—´ï¼š4Ï€',
                        'â€¢ ç»¿è‰²ç²’å­ï¼šæœ‰æ•ˆä½œç”¨<br>â€¢ ç°è‰²ç²’å­ï¼šæ— æ•ˆä½œç”¨<br>â€¢ é»„è‰²åŠçƒï¼šæœ‰æ•ˆåŒºåŸŸ'
                    );
                    break;
                    
                case 3:
                    panels.forEach(panel => panel.classList.add('projection-mode'));
                    updateStepContent(
                        'ğŸ“ æŠ•å½±æƒé‡æ¨¡å¼',
                        'æ­¥éª¤3ï¼šè®¡ç®—sinÂ²Î¸æƒé‡æ•ˆåº”', 
                        'ä¸åŒè§’åº¦Î¸çš„ä½œç”¨æ•ˆæœä¸åŒ<br>Î¸=90Â°æ•ˆæœæœ€å¼ºï¼ŒÎ¸=0Â°,180Â°æ•ˆæœä¸ºé›¶',
                        'â€¢ é¢œè‰²æ·±æµ…ï¼šsinÂ²Î¸å¤§å°<br>â€¢ ç²’å­å¤§å°ï¼šæƒé‡æ•ˆåº”<br>â€¢ ç´«è‰²é¢ï¼šæŠ•å½±å¹³é¢'
                    );
                    break;
                    
                case 4:
                    panels.forEach(panel => panel.classList.add('factor-mode'));
                    updateStepContent(
                        'âœ¨ å‡ ä½•å› å­æ¨å¯¼',
                        'æ­¥éª¤4ï¼šä¸ºä»€ä¹ˆå› å­æ˜¯2',
                        'æœ‰æ•ˆä½œç”¨æ¯”ä¾‹=1/2ï¼Œéœ€è¦æ”¾å¤§2å€<br>å‡ ä½•å› å­ = 1 Ã· æœ‰æ•ˆæ¯”ä¾‹ = 2',
                        'â€¢ é«˜äº®ç²’å­ï¼šÃ—2æ•ˆæœ<br>â€¢ è¾‰å…‰æ•ˆåº”ï¼šå€å¢å¯è§†åŒ–<br>â€¢ æœ€ç»ˆç­”æ¡ˆï¼š2'
                    );
                    break;
            }
        }
        
        function updateStepContent(title, step, concept, observation) {
            document.querySelector('.step-title').textContent = title;
            document.getElementById('current-step').textContent = step;
            document.getElementById('concept-text').innerHTML = concept;
            document.getElementById('observation-text').innerHTML = observation;
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('anim-btn').textContent = isAnimating ? 'æš‚åœ' : 'ç»§ç»­';
        }
        
        function resetDemo() {
            time = 0;
            stepData.progress = 0;
            setStep(1);
        }
        
        function updateParticles() {
            createParticleSystem();
        }
        
        function resetCamera() {
            camera.position.set(40, 25, 40);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleProjection() {
            projectionPlane.visible = !projectionPlane.visible;
        }
        
        function showWrongMethod() {
            // æ˜¾ç¤ºé”™è¯¯çš„cosÎ¸æ–¹æ³•
            document.getElementById('wrong-btn').classList.add('active');
            document.getElementById('correct-btn').classList.remove('active');
            
            // æ›´æ–°è®¡ç®—æ˜¾ç¤º
            document.getElementById('sin2-integral').innerHTML = '<span class="error-highlight">0</span>';
            document.getElementById('effect-ratio').innerHTML = '<span class="error-highlight">0</span>';
            document.getElementById('big-number').innerHTML = '<span class="error-highlight">âˆ</span>';
            
            // ä¿®æ”¹ç²’å­æ˜¾ç¤ºé€»è¾‘ï¼ˆä¸´æ—¶æ¼”ç¤ºé”™è¯¯æ–¹æ³•ï¼‰
            particles.forEach(particle => {
                const userData = particle.userData;
                const cosTheta = Math.cos(userData.theta);
                
                if (Math.abs(cosTheta) > 0.1) {
                    particle.material.opacity = Math.abs(cosTheta) * 0.8;
                    particle.material.color.setHex(0xff4444); // çº¢è‰²è¡¨ç¤ºé”™è¯¯
                } else {
                    particle.material.opacity = 0.05;
                }
            });
        }
        
        function showCorrectMethod() {
            // æ˜¾ç¤ºæ­£ç¡®çš„sinÂ²Î¸æ–¹æ³•
            document.getElementById('correct-btn').classList.add('active');
            document.getElementById('wrong-btn').classList.remove('active');
            
            // æ¢å¤æ­£ç¡®è®¡ç®—æ˜¾ç¤º
            document.getElementById('sin2-integral').innerHTML = 'Ï€/2';
            document.getElementById('effect-ratio').innerHTML = '1/2';
            document.getElementById('big-number').innerHTML = '2';
            
            // æ¢å¤æ­£ç¡®çš„ç²’å­æ˜¾ç¤º
            // è¿™ä¼šåœ¨ä¸‹ä¸€æ¬¡animateå¾ªç¯ä¸­è‡ªåŠ¨æ›´æ­£
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // å¯åŠ¨åº”ç”¨
        init();
        
        // è‡ªåŠ¨æ¼”ç¤ºå¾ªç¯ï¼ˆå¯é€‰ï¼‰
        setInterval(() => {
            if (isAnimating) {
                const nextStep = (currentStep % 4) + 1;
                // setStep(nextStep); // å–æ¶ˆæ³¨é‡Šå¯å¯ç”¨è‡ªåŠ¨å¾ªç¯
            }
        }, 10000); // æ¯10ç§’åˆ‡æ¢ä¸€æ­¥
    </script>
</body>
</html>