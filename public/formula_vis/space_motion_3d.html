<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®—æ³•è”ç›Ÿ - å¼ ç¥¥å‰ç»Ÿä¸€åœºè®ºç»ˆæå¯è§†åŒ– v2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@300;500;700&display=swap');
        
        :root {
            --primary-glow: #00f5ff;
            --secondary-glow: #ff0080;
            --accent-glow: #8000ff;
            --bg-dark: #0a0a0f;
            --bg-panel: rgba(10, 15, 35, 0.95);
            --border-glow: rgba(0, 245, 255, 0.6);
            --text-primary: #ffffff;
            --text-secondary: #00f5ff;
            --shadow-glow: 0 0 30px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a0f2e 0%, #0f0518 50%, #000000 100%);
            font-family: 'Orbitron', monospace;
            color: var(--text-primary);
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        /* ç®—æ³•è”ç›Ÿæ ‡è¯† */
        .alliance-brand {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: linear-gradient(135deg, var(--primary-glow), var(--secondary-glow));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 24px;
            font-weight: 900;
            text-shadow: var(--shadow-glow) var(--primary-glow);
            animation: brandPulse 3s ease-in-out infinite;
        }
        
        @keyframes brandPulse {
            0%, 100% { opacity: 0.8; transform: translateX(-50%) scale(1); }
            50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
        }
        
        /* è¶…çº§é¢æ¿ç³»ç»Ÿ */
        .super-panel {
            position: absolute;
            background: var(--bg-panel);
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            backdrop-filter: blur(25px);
            box-shadow: var(--shadow-glow) var(--primary-glow);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .super-panel:hover {
            border-color: var(--secondary-glow);
            box-shadow: var(--shadow-glow) var(--secondary-glow);
            transform: scale(1.02);
        }
        
        .super-panel.minimized {
            opacity: 0.7;
            transform: scale(0.9);
        }
        
        /* æ§åˆ¶é¢æ¿å¸ƒå±€ä¼˜åŒ– */
        #main-controls {
            top: 60px;
            left: 20px;
            width: 400px;
            max-height: 85vh;
            padding: 25px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-glow) transparent;
        }
        
        #advanced-controls {
            top: 60px;
            right: 20px;
            width: 380px;
            max-height: 85vh;
            padding: 25px;
            overflow-y: auto;
        }
        
        #theory-display {
            bottom: 20px;
            left: 20px;
            width: 520px;
            max-height: 350px;
            padding: 25px;
            overflow-y: auto;
        }
        
        #stats-monitor {
            bottom: 20px;
            right: 20px;
            width: 300px;
            padding: 20px;
        }
        
        /* é¢æ¿å¤´éƒ¨ */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-glow);
        }
        
        .panel-title {
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(45deg, var(--primary-glow), var(--secondary-glow));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .minimize-btn {
            background: none;
            border: 1px solid var(--border-glow);
            color: var(--text-secondary);
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .minimize-btn:hover {
            background: var(--primary-glow);
            color: var(--bg-dark);
            box-shadow: 0 0 15px var(--primary-glow);
        }
        
        /* è¶…çº§æ§åˆ¶ç»„ */
        .super-control-group {
            margin: 25px 0;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.05), rgba(255, 0, 128, 0.05));
            border: 1px solid rgba(0, 245, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .super-control-group::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-glow), transparent);
            animation: scanLine 3s ease-in-out infinite;
        }
        
        @keyframes scanLine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .super-control-group:hover {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.1), rgba(255, 0, 128, 0.1));
            border-color: var(--secondary-glow);
            transform: translateY(-2px);
        }
        
        /* æ™ºèƒ½æ ‡ç­¾ç³»ç»Ÿ */
        .smart-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-secondary);
            text-shadow: 0 0 10px var(--primary-glow);
        }
        
        .param-value {
            background: rgba(0, 245, 255, 0.1);
            padding: 4px 10px;
            border-radius: 8px;
            border: 1px solid var(--primary-glow);
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: var(--primary-glow);
            text-shadow: 0 0 5px var(--primary-glow);
            min-width: 60px;
            text-align: center;
        }
        
        /* é‡å­æ»‘å—ç³»ç»Ÿ */
        .quantum-slider {
            position: relative;
            width: 100%;
            height: 12px;
            margin: 15px 0;
        }
        
        .quantum-slider input[type="range"] {
            width: 100%;
            height: 12px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            position: relative;
            z-index: 2;
        }
        
        .quantum-slider input[type="range"]::-webkit-slider-track {
            background: linear-gradient(90deg, 
                rgba(0, 245, 255, 0.3) 0%, 
                rgba(255, 0, 128, 0.3) 50%, 
                rgba(128, 0, 255, 0.3) 100%);
            height: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-glow);
            box-shadow: inset 0 0 10px rgba(0, 245, 255, 0.2);
        }
        
        .quantum-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: radial-gradient(circle, var(--primary-glow), var(--secondary-glow));
            border-radius: 50%;
            border: 3px solid var(--text-primary);
            cursor: pointer;
            box-shadow: 0 0 20px var(--primary-glow), inset 0 0 10px rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .quantum-slider input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
            box-shadow: 0 0 30px var(--primary-glow), inset 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        .quantum-slider input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.1);
            box-shadow: 0 0 40px var(--secondary-glow);
        }
        
        /* è¿›åº¦å…‰ç¯ */
        .progress-ring {
            position: absolute;
            top: -6px;
            left: 0;
            width: 100%;
            height: 24px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                var(--primary-glow) var(--progress, 50%), 
                transparent var(--progress, 50%));
            border-radius: 12px;
            opacity: 0.3;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        /* è¶…çº§æŒ‰é’®ç³»ç»Ÿ */
        .super-btn {
            background: linear-gradient(135deg, var(--primary-glow), var(--secondary-glow));
            border: none;
            color: var(--bg-dark);
            padding: 14px 20px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 13px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
            margin: 8px 4px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 245, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .super-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s ease;
        }
        
        .super-btn:hover::before {
            left: 100%;
        }
        
        .super-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 245, 255, 0.6);
        }
        
        .super-btn:active {
            transform: translateY(-1px) scale(0.98);
        }
        
        .super-btn.active {
            background: linear-gradient(135deg, var(--secondary-glow), var(--accent-glow));
            box-shadow: 0 4px 20px rgba(255, 0, 128, 0.5);
        }
        
        /* é¢„è®¾æŒ‰é’®ç½‘æ ¼ */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 20px 0;
        }
        
        .preset-btn {
            background: linear-gradient(45deg, var(--accent-glow), var(--primary-glow));
            border: none;
            color: var(--text-primary);
            padding: 12px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }
        
        .preset-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transition: all 0.4s ease;
            transform: translate(-50%, -50%);
        }
        
        .preset-btn:hover::after {
            width: 100%;
            height: 100%;
        }
        
        .preset-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(128, 0, 255, 0.5);
        }
        
        /* å…¬å¼æ˜¾ç¤ºç³»ç»Ÿ */
        .formula-display {
            background: linear-gradient(135deg, 
                rgba(0, 245, 255, 0.15), 
                rgba(128, 0, 255, 0.15));
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            border: 2px solid rgba(0, 245, 255, 0.3);
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            box-shadow: inset 0 0 20px rgba(0, 245, 255, 0.1);
            position: relative;
        }
        
        .formula-display::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary-glow), var(--secondary-glow), var(--accent-glow));
            border-radius: 15px;
            z-index: -1;
            opacity: 0.3;
        }
        
        /* ç‰©ç†æ¦‚å¿µå¡ç‰‡ */
        .physics-card {
            background: linear-gradient(135deg, 
                rgba(255, 200, 0, 0.1), 
                rgba(255, 100, 0, 0.1));
            border-left: 4px solid #ffcc00;
            padding: 15px;
            margin: 12px 0;
            border-radius: 10px;
            font-size: 13px;
            line-height: 1.7;
            box-shadow: 0 4px 15px rgba(255, 200, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .physics-card:hover {
            background: linear-gradient(135deg, 
                rgba(255, 200, 0, 0.15), 
                rgba(255, 100, 0, 0.15));
            transform: translateX(5px);
        }
        
        /* çŠ¶æ€ç›‘æ§ç³»ç»Ÿ */
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        .status-item {
            background: linear-gradient(135deg, 
                rgba(0, 255, 136, 0.1), 
                rgba(0, 245, 255, 0.1));
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .status-item:hover {
            background: linear-gradient(135deg, 
                rgba(0, 255, 136, 0.2), 
                rgba(0, 245, 255, 0.2));
            transform: scale(1.05);
        }
        
        .status-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status-value {
            font-size: 16px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', monospace;
            text-shadow: 0 0 10px #00ff88;
        }
        
        /* å·¥å…·æç¤ºç³»ç»Ÿ */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            border: 1px solid var(--primary-glow);
            box-shadow: 0 5px 15px rgba(0, 245, 255, 0.3);
            z-index: 1000;
        }
        
        .tooltip:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        /* å“åº”å¼ä¼˜åŒ– */
        @media (max-width: 1600px) {
            #main-controls, #advanced-controls { width: 350px; }
            #theory-display { width: 450px; }
            #stats-monitor { width: 280px; }
        }
        
        @media (max-width: 1200px) {
            .super-panel { transform: scale(0.9); }
            #main-controls, #advanced-controls { width: 300px; }
            #theory-display { width: 400px; max-height: 250px; }
        }
        
        @media (max-width: 900px) {
            .super-panel { 
                position: fixed !important;
                transform: scale(0.8);
                z-index: 100;
            }
            .alliance-brand { font-size: 18px; }
        }
        
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, var(--primary-glow), var(--secondary-glow));
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, var(--secondary-glow), var(--accent-glow));
        }
        
        /* åŠ¨ç”»å…³é”®å¸§ */
        @keyframes quantumGlow {
            0%, 100% { box-shadow: 0 0 20px var(--primary-glow); }
            50% { box-shadow: 0 0 40px var(--secondary-glow); }
        }
        
        @keyframes dataStream {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes particleFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        /* æ€§èƒ½ä¼˜åŒ–ç±» */
        .gpu-accelerated {
            transform: translateZ(0);
            will-change: transform;
        }
        
        .no-select {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }
    </style>
</head>
<body>
    <div id="container" class="no-select">
        <!-- ç®—æ³•è”ç›Ÿå“ç‰Œæ ‡è¯† -->
        <div class="alliance-brand">âš¡ ALGORITHM ALLIANCE âš¡</div>
        
        <!-- ä¸»æ§åˆ¶é¢æ¿ -->
        <div id="main-controls" class="super-panel gpu-accelerated">
            <div class="panel-header">
                <div class="panel-title">ğŸŒŒ æ ¸å¿ƒå‚æ•°æ§åˆ¶</div>
                <button class="minimize-btn" onclick="togglePanel('main-controls')">âˆ’</button>
            </div>
            
            <!-- å¿«é€Ÿé¢„è®¾ -->
            <div class="super-control-group">
                <div class="smart-label">âš¡ å¿«é€Ÿé¢„è®¾é…ç½®</div>
                <div class="preset-grid">
                    <button class="preset-btn" onclick="loadPreset('default')">ğŸ¯ æ ‡å‡†åœº</button>
                    <button class="preset-btn" onclick="loadPreset('intense')">âš¡ å¼ºåŠ›åœº</button>
                    <button class="preset-btn" onclick="loadPreset('gentle')">ğŸŒ¸ æ¸©å’Œåœº</button>
                    <button class="preset-btn" onclick="loadPreset('spiral')">ğŸŒ€ èºæ—‹åœº</button>
                    <button class="preset-btn" onclick="loadPreset('quantum')">âš›ï¸ é‡å­åœº</button>
                    <button class="preset-btn" onclick="loadPreset('cosmic')">ğŸŒŒ å®‡å®™åœº</button>
                </div>
            </div>
            
            <!-- å‘æ•£æ–¹å‘æ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label tooltip" data-tooltip="ç©ºé—´å‘æ•£çš„å¯¹ç§°æ–¹å‘æ•°é‡ï¼Œå½±å“åœºçš„å®Œæ•´æ€§">
                    ğŸ¯ å‘æ•£æ–¹å‘æ•° N
                    <div class="param-value" id="directionCount">14</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="directions" min="8" max="30" value="14" step="2">
                    <div class="progress-ring" style="--progress: 33%"></div>
                </div>
            </div>
            
            <!-- èºæ—‹å‚æ•°æ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label tooltip" data-tooltip="èºæ—‹è¿åŠ¨çš„è§’é¢‘ç‡ï¼Œå½±å“ç£åœºåˆ†é‡å¼ºåº¦">
                    âš¡ èºæ—‹è§’é¢‘ç‡ Ï‰
                    <div class="param-value" id="omegaValue">1.5</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="omega" min="0.1" max="5.0" value="1.5" step="0.1">
                    <div class="progress-ring" style="--progress: 28%"></div>
                </div>
            </div>
            
            <!-- å…‰é€Ÿæ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label tooltip" data-tooltip="çŸ¢é‡å…‰é€Ÿçš„å¤§å°ï¼Œç©ºé—´å‘æ•£çš„åŸºæœ¬é€Ÿåº¦">
                    ğŸ’« çŸ¢é‡å…‰é€Ÿ |Câƒ—|
                    <div class="param-value" id="velocityValue">1.0c</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="velocity" min="0.2" max="3.0" value="1.0" step="0.1">
                    <div class="progress-ring" style="--progress: 29%"></div>
                </div>
            </div>
            
            <!-- èºæ—‹åŠå¾„æ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label tooltip" data-tooltip="èºæ—‹è¿åŠ¨çš„åŠå¾„ï¼Œå½±å“åœºçš„ç©ºé—´åˆ†å¸ƒ">
                    ğŸŒ€ èºæ—‹åŠå¾„ R
                    <div class="param-value" id="radiusValue">0.8</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="radius" min="0.1" max="2.5" value="0.8" step="0.1">
                    <div class="progress-ring" style="--progress: 29%"></div>
                </div>
            </div>
            
            <!-- è´¨é‡å‚æ•°æ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label tooltip" data-tooltip="è´¨é‡å‚æ•°ï¼Œå½±å“ç©ºé—´çŸ¢é‡å¯†åº¦å’Œç²’å­æ•°é‡">
                    âš›ï¸ è´¨é‡å‚æ•° m
                    <div class="param-value" id="massValue">1.0</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="mass" min="0.3" max="4.0" value="1.0" step="0.1">
                    <div class="progress-ring" style="--progress: 18%"></div>
                </div>
            </div>
        </div>
        
        <!-- é«˜çº§æ§åˆ¶é¢æ¿ -->
        <div id="advanced-controls" class="super-panel gpu-accelerated">
            <div class="panel-header">
                <div class="panel-title">ğŸ® é«˜çº§æ§åˆ¶ç³»ç»Ÿ</div>
                <button class="minimize-btn" onclick="togglePanel('advanced-controls')">âˆ’</button>
            </div>
            
            <!-- åŠ¨ç”»æ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label">ğŸ¬ åŠ¨ç”»ç³»ç»Ÿæ§åˆ¶</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="super-btn" id="playPauseBtn" onclick="toggleAnimation()">â¸ï¸ æš‚åœ</button>
                    <button class="super-btn" onclick="resetSimulation()">ğŸ”„ é‡ç½®</button>
                    <button class="super-btn" onclick="stepAnimation()">â­ï¸ å•æ­¥</button>
                </div>
                
                <div class="smart-label" style="margin-top: 15px;">
                    âš¡ åŠ¨ç”»é€Ÿåº¦
                    <div class="param-value" id="speedValue">1.0x</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="animSpeed" min="0.1" max="4.0" value="1.0" step="0.1">
                    <div class="progress-ring" style="--progress: 23%"></div>
                </div>
            </div>
            
            <!-- è§†è§‰æ•ˆæœæ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label">ğŸ¨ è§†è§‰æ•ˆæœç³»ç»Ÿ</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="super-btn" id="vectorBtn" onclick="toggleVectors()">ğŸ“ çŸ¢é‡åœº</button>
                    <button class="super-btn" id="trailBtn" onclick="toggleTrails()">âœ¨ ç²’å­è½¨è¿¹</button>
                    <button class="super-btn" id="fieldBtn" onclick="toggleFieldLines()">ğŸŒŠ åœºçº¿</button>
                </div>
                
                <div style="margin-top: 15px;">
                    <div class="smart-label">ğŸŒˆ è‰²å½©ä¸»é¢˜</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button class="preset-btn" onclick="changeColorScheme('quantum')">âš›ï¸ é‡å­</button>
                        <button class="preset-btn" onclick="changeColorScheme('aurora')">ğŸŒŒ æå…‰</button>
                        <button class="preset-btn" onclick="changeColorScheme('nebula')">â˜„ï¸ æ˜Ÿäº‘</button>
                        <button class="preset-btn" onclick="changeColorScheme('plasma')">âš¡ ç­‰ç¦»å­</button>
                    </div>
                </div>
            </div>
            
            <!-- ç›¸æœºæ§åˆ¶ -->
            <div class="super-control-group">
                <div class="smart-label">ğŸ“¹ æ™ºèƒ½ç›¸æœºç³»ç»Ÿ</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="super-btn" id="cameraBtn" onclick="cycleCameraMode()">ğŸ”„ è½¨é“æ¨¡å¼</button>
                    <button class="super-btn" onclick="resetCamera()">ğŸ¯ é‡ç½®è§†è§’</button>
                    <button class="super-btn" onclick="autoFocus()">ğŸ” è‡ªåŠ¨èšç„¦</button>
                </div>
                
                <div class="smart-label" style="margin-top: 15px;">
                    ğŸ“ è§†åœºè·ç¦»
                    <div class="param-value" id="cameraDistance">15.0</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="cameraDistanceSlider" min="5" max="50" value="15" step="1">
                    <div class="progress-ring" style="--progress: 22%"></div>
                </div>
            </div>
            
            <!-- é«˜çº§ç‰©ç†å‚æ•° -->
            <div class="super-control-group">
                <div class="smart-label">âš›ï¸ é«˜çº§ç‰©ç†å‚æ•°</div>
                
                <div class="smart-label" style="margin-top: 10px;">
                    ğŸŒŠ åœºå¼ºè¡°å‡ç³»æ•°
                    <div class="param-value" id="decayValue">1.0</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="fieldDecay" min="0.1" max="3.0" value="1.0" step="0.1">
                    <div class="progress-ring" style="--progress: 31%"></div>
                </div>
                
                <div class="smart-label" style="margin-top: 10px;">
                    ğŸ’« ç²’å­å¯†åº¦
                    <div class="param-value" id="densityValue">1.0</div>
                </div>
                <div class="quantum-slider">
                    <input type="range" id="particleDensity" min="0.2" max="3.0" value="1.0" step="0.1">
                    <div class="progress-ring" style="--progress: 29%"></div>
                </div>
            </div>
            
            <!-- ç³»ç»Ÿæ“ä½œ -->
            <div class="super-control-group">
                <div class="smart-label">ğŸ”§ ç³»ç»Ÿæ“ä½œ</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="super-btn" onclick="captureFrame()">ğŸ“¸ æˆªå›¾</button>
                    <button class="super-btn" onclick="exportData()">ğŸ’¾ å¯¼å‡ºæ•°æ®</button>
                    <button class="super-btn" onclick="toggleFullscreen()">ğŸ–¥ï¸ å…¨å±</button>
                </div>
            </div>
        </div>
        
        <!-- ç†è®ºæ˜¾ç¤ºé¢æ¿ -->
        <div id="theory-display" class="super-panel gpu-accelerated">
            <div class="panel-header">
                <div class="panel-title">ğŸ“š ç»Ÿä¸€åœºè®ºæ ¸å¿ƒæ–¹ç¨‹</div>
                <button class="minimize-btn" onclick="togglePanel('theory-display')">âˆ’</button>
            </div>
            
            <div class="formula-display">
                râƒ—(t) = Câƒ—t = |Câƒ—|t Â· Ã»_r
            </div>
            <div class="physics-card">
                â° <strong>æ—¶ç©ºåŒä¸€åŒ–å®šç†ï¼š</strong>æ—¶é—´çš„æœ¬è´¨æ˜¯ç©ºé—´ä»¥å…‰é€Ÿè¿åŠ¨çš„åº¦é‡ã€‚æ—¶é—´ä¸æ˜¯ç‹¬ç«‹ç»´åº¦ï¼Œè€Œæ˜¯ç©ºé—´è¿åŠ¨çš„è¡¨å¾ã€‚
            </div>
            
            <div class="formula-display">
                èºæ—‹è¿åŠ¨: râƒ— = R cos(Ï‰t)Ãªâ‚ + R sin(Ï‰t)Ãªâ‚‚ + v_z t Ãªâ‚ƒ
            </div>
            <div class="physics-card">
                ğŸŒ€ <strong>åœ†æŸ±èºæ—‹ç†è®ºï¼š</strong>ç©ºé—´è¿åŠ¨ç”±æ—‹è½¬åˆ†é‡ï¼ˆç£åœºæœ¬è´¨ï¼‰å’Œç›´çº¿åˆ†é‡ï¼ˆç”µåœºæœ¬è´¨ï¼‰å¤åˆè€Œæˆï¼Œç»Ÿä¸€äº†ç”µç£ç°è±¡ã€‚
            </div>
            
            <div class="formula-display">
                è´¨é‡å®šä¹‰: m = k(dn/dÎ©)
            </div>
            <div class="physics-card">
                âš›ï¸ <strong>è´¨é‡èµ·æºç†è®ºï¼š</strong>è´¨é‡ä¸æ˜¯ç‰©è´¨çš„å†…åœ¨å±æ€§ï¼Œè€Œæ˜¯å•ä½ç«‹ä½“è§’å†…ç©ºé—´ä½ç§»çŸ¢é‡çš„å¯†åº¦ï¼Œä½“ç°äº†ç‰©ä½“å¯¹å‘¨å›´ç©ºé—´çš„æ‰°åŠ¨ç¨‹åº¦ã€‚
            </div>
            
            <div class="physics-card">
                ğŸ¯ <strong>14æ–¹å‘å¯¹ç§°æ€§ï¼š</strong>åŸºäºä¸‰ç»´ç©ºé—´çš„æœ€å¤§å¯¹ç§°åˆ†å¸ƒåŸç†ï¼ŒåŒ…å«6ä¸ªä¸»è½´æ–¹å‘å’Œ8ä¸ªå¯¹è§’æ–¹å‘ï¼Œç¡®ä¿ç©ºé—´è¿åŠ¨çš„å®Œæ•´æ€§å’Œå„å‘åŒæ€§ï¼Œä½“ç°äº†å®‡å®™çš„åŸºæœ¬å¯¹ç§°æ€§ã€‚
            </div>
            
            <div class="physics-card">
                ğŸŒŒ <strong>å¼•åŠ›ç»Ÿä¸€è§£é‡Šï¼š</strong>å¼•åŠ›ä¸æ˜¯ç‹¬ç«‹çš„åŸºæœ¬åŠ›ï¼Œè€Œæ˜¯ç©ºé—´èºæ—‹è¿åŠ¨äº§ç”Ÿçš„å‘å¿ƒåŠ é€Ÿåº¦æ•ˆåº”ã€‚ä¸¤ä¸ªç‰©ä½“é—´çš„å¼•åŠ›ç›¸äº’ä½œç”¨æœ¬è´¨ä¸Šæ˜¯å„è‡ªç©ºé—´è¿åŠ¨åœºçš„è€¦åˆç»“æœã€‚
            </div>
        </div>
        
        <!-- çŠ¶æ€ç›‘æ§é¢æ¿ -->
        <div id="stats-monitor" class="super-panel gpu-accelerated">
            <div class="panel-header">
                <div class="panel-title">ğŸ“Š å®æ—¶çŠ¶æ€ç›‘æ§</div>
                <button class="minimize-btn" onclick="togglePanel('stats-monitor')">âˆ’</button>
            </div>
            
            <div class="status-grid">
                <div class="status-item tooltip" data-tooltip="å½“å‰æ¨¡æ‹Ÿæ—¶é—´å‚æ•°">
                    <div class="status-label">â±ï¸ æ¨¡æ‹Ÿæ—¶é—´</div>
                    <div class="status-value" id="timeValue">0.00s</div>
                </div>
                
                <div class="status-item tooltip" data-tooltip="ç³»ç»Ÿæ¸²æŸ“å¸§ç‡">
                    <div class="status-label">ğŸ“ˆ å®æ—¶FPS</div>
                    <div class="status-value" id="fpsCounter">60</div>
                </div>
                
                <div class="status-item tooltip" data-tooltip="æ´»è·ƒç²’å­æ€»æ•°">
                    <div class="status-label">ğŸ¯ æ´»è·ƒç²’å­</div>
                    <div class="status-value" id="particleCount">0</div>
                </div>
                
                <div class="status-item tooltip" data-tooltip="å¹³å‡åœºå¼ºåº¦å€¼">
                    <div class="status-label">âš¡ å¹³å‡åœºå¼º</div>
                    <div class="status-value" id="fieldStrength">0.00</div>
                </div>
                
                <div class="status-item tooltip" data-tooltip="ç©ºé—´æ›²ç‡å‚æ•°">
                    <div class="status-label">ğŸŒŒ ç©ºé—´æ›²ç‡</div>
                    <div class="status-value" id="curvature">0.00</div>
                </div>
                
                <div class="status-item tooltip" data-tooltip="ç³»ç»Ÿèƒ½é‡æ€»å€¼">
                    <div class="status-label">ğŸ’« ç³»ç»Ÿèƒ½é‡</div>
                    <div class="status-value" id="systemEnergy">1.00</div>
                </div>
                
                <div class="status-item tooltip" data-tooltip="æ´»è·ƒæ–¹å‘æ•°é‡">
                    <div class="status-label">ğŸ¯ æ´»è·ƒæ–¹å‘</div>
                    <div class="status-value" id="activeDirections">14</div>
                </div>
                
                <div class="status-item tooltip" data-tooltip="åœºç›¸å¹²æ€§æŒ‡æ•°">
                    <div class="status-label">ğŸ”— åœºç›¸å¹²æ€§</div>
                    <div class="status-value" id="coherence">0.85</div>
                </div>
            </div>
            
            <!-- ç³»ç»ŸçŠ¶æ€æŒ‡ç¤º -->
            <div class="super-control-group" style="margin-top: 20px;">
                <div class="smart-label">ğŸš¦ ç³»ç»ŸçŠ¶æ€</div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <div class="status-indicator" id="systemStatus">ğŸŸ¢ è¿è¡Œæ­£å¸¸</div>
                </div>
                <div style="margin-top: 10px; font-size: 11px; color: rgba(255,255,255,0.6);">
                    å†…å­˜ä½¿ç”¨: <span id="memoryUsage">æ­£å¸¸</span> | 
                    GPUåˆ©ç”¨: <span id="gpuUsage">ä¼˜åŒ–</span> | 
                    ç½‘æ ¼å¤æ‚åº¦: <span id="meshComplexity">ä¸­ç­‰</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ğŸ¤– ç®—æ³•è”ç›Ÿ - ç»ˆæä¼˜åŒ–æ ¸å¿ƒç³»ç»Ÿ v2.0
        
        // === å…¨å±€çŠ¶æ€ç®¡ç† ===
        class UnifiedFieldSystem {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.centralMass = null;
                
                this.spiralGroups = [];
                this.particleSystems = [];
                this.fieldLines = [];
                this.trailSystems = [];
                this.vectorHelpers = [];
                
                this.time = 0;
                this.animationSpeed = 1.0;
                this.isAnimating = true;
                this.showVectors = false;
                this.showTrails = false;
                this.showFieldLines = false;
                
                this.cameraMode = 'orbit'; // orbit, follow, free, cinematic
                this.colorScheme = 'quantum';
                this.fieldDecay = 1.0;
                this.particleDensity = 1.0;
                
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fpsHistory = [];
                
                this.mouseX = 0;
                this.mouseY = 0;
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                this.cameraDistance = 15;
                
                this.isInitialized = false;
            }
            
            // é«˜çº§é¢„è®¾ç³»ç»Ÿ
            getPresets() {
                return {
                    default: { directions: 14, omega: 1.5, velocity: 1.0, radius: 0.8, mass: 1.0, decay: 1.0, density: 1.0 },
                    intense: { directions: 22, omega: 3.5, velocity: 2.2, radius: 1.4, mass: 2.8, decay: 0.7, density: 1.8 },
                    gentle: { directions: 10, omega: 0.8, velocity: 0.6, radius: 0.5, mass: 0.6, decay: 1.5, density: 0.7 },
                    spiral: { directions: 18, omega: 4.2, velocity: 1.8, radius: 1.8, mass: 1.6, decay: 0.9, density: 1.4 },
                    quantum: { directions: 26, omega: 2.8, velocity: 1.5, radius: 1.0, mass: 2.2, decay: 0.8, density: 2.0 },
                    cosmic: { directions: 30, omega: 1.2, velocity: 2.8, radius: 2.2, mass: 3.5, decay: 0.6, density: 2.5 }
                };
            }
            
            // é«˜çº§é¢œè‰²æ–¹æ¡ˆ
            getColorSchemes() {
                return {
                    quantum: { 
                        primary: 0x00f5ff, secondary: 0xff0080, accent: 0x8000ff,
                        bg: 0x0a0a0f, particle: 0x00ddff 
                    },
                    aurora: { 
                        primary: 0x00ff88, secondary: 0xff4488, accent: 0x8844ff,
                        bg: 0x0f1a0f, particle: 0x44ff88 
                    },
                    nebula: { 
                        primary: 0xff6b35, secondary: 0xf7931e, accent: 0xff005d,
                        bg: 0x1a0f05, particle: 0xff8844 
                    },
                    plasma: { 
                        primary: 0xff0080, secondary: 0x8000ff, accent: 0x00ff80,
                        bg: 0x1a051a, particle: 0xff4080 
                    }
                };
            }
        }
        
        // å…¨å±€ç³»ç»Ÿå®ä¾‹
        const unifiedField = new UnifiedFieldSystem();
        
        // === é«˜çº§å‡ ä½•ç®—æ³• ===
        function generateOptimizedDirections(count) {
            const directions = [];
            
            // åŸºç¡€6æ–¹å‘ï¼ˆä¸»è½´ï¼‰
            if (count >= 6) {
                directions.push(
                    [1,0,0], [-1,0,0], [0,1,0], 
                    [-1,0], [0,0,1], [0,0,-1]
                );
            }
            
            // æ ‡å‡†8æ–¹å‘ï¼ˆç«‹æ–¹ä½“é¡¶ç‚¹ï¼‰
            if (count >= 14) {
                const diagonals = [
                    [1,1,1], [-1,1,1], [1,-1,1], [1,1,-1],
                    [-1,-1,1], [-1,1,-1], [1,-1,-1], [-1,-1,-1]
                ];
                directions.push(...diagonals.map(d => {
                    const len = Math.sqrt(d[0]**2 + d[1]**2 + d[2]**2);
                    return [d[0]/len, d[1]/len, d[2]/len];
                }));
            }
            
            // é«˜é˜¶å¯¹ç§°æ–¹å‘ï¼ˆäºŒåé¢ä½“é¡¶ç‚¹ï¼‰
            if (count >= 20) {
                const phi = (1 + Math.sqrt(5)) / 2; // é»„é‡‘æ¯”ä¾‹
                const icosahedron = [
                    [1, phi, 0], [-1, phi, 0], [1, -phi, 0], [-1, -phi, 0],
                    [0, 1, phi], [0, -1, phi], [0, 1, -phi], [0, -1, -phi],
                    [phi, 0, 1], [-phi, 0, 1], [phi, 0, -1], [-phi, 0, -1]
                ];
                directions.push(...icosahedron.map(d => {
                    const len = Math.sqrt(d[0]**2 + d[1]**2 + d[2]**2);
                    return [d[0]/len, d[1]/len, d[2]/len];
                }));
            }
            
            // çƒé¢å‡åŒ€åˆ†å¸ƒï¼ˆFibonacciçƒé¢ï¼‰
            while (directions.length < count) {
                const i = directions.length;
                const theta = 2 * Math.PI * i / ((1 + Math.sqrt(5)) / 2);
                const phi = Math.acos(1 - 2 * i / count);
                directions.push([
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                ]);
            }
            
            return directions.slice(0, count);
        }
        
        // === ç³»ç»Ÿåˆå§‹åŒ– ===
        function initializeSystem() {
            console.log('ğŸš€ ç®—æ³•è”ç›Ÿ - åˆå§‹åŒ–ç»Ÿä¸€åœºè®ºç³»ç»Ÿ...');
            
            // åœºæ™¯è®¾ç½®
            unifiedField.scene = new THREE.Scene();
            unifiedField.scene.fog = new THREE.Fog(0x0a0a0f, 20, 100);
            
            // ç›¸æœºè®¾ç½®
            unifiedField.camera = new THREE.PerspectiveCamera(
                65, window.innerWidth / window.innerHeight, 0.1, 500
            );
            unifiedField.camera.position.set(15, 10, 15);
            unifiedField.camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“å™¨è®¾ç½®ï¼ˆé«˜çº§ä¼˜åŒ–ï¼‰
            unifiedField.renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                preserveDrawingBuffer: true,
                powerPreference: "high-performance"
            });
            unifiedField.renderer.setSize(window.innerWidth, window.innerHeight);
            unifiedField.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            unifiedField.renderer.setClearColor(0x0a0a0f, 0.1);
            
            // é«˜çº§æ¸²æŸ“è®¾ç½®
            unifiedField.renderer.shadowMap.enabled = true;
            unifiedField.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            unifiedField.renderer.outputEncoding = THREE.sRGBEncoding;
            unifiedField.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            unifiedField.renderer.toneMappingExposure = 1.0;
            
            document.getElementById('container').appendChild(unifiedField.renderer.domElement);
            
            // åˆ›å»ºæ ¸å¿ƒç»„ä»¶
            createAdvancedCentralMass();
            createSuperiorSpatialSystem();
            setupAdvancedLighting();
            setupSmartControls();
            setupAdvancedInteraction();
            
            console.log('âœ… ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ - æ€§èƒ½æ¨¡å¼å·²æ¿€æ´»');
            unifiedField.isInitialized = true;
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }
        
        // === é«˜çº§ä¸­å¿ƒè´¨é‡ç³»ç»Ÿ ===
        function createAdvancedCentralMass() {
            const mass = parseFloat(document.getElementById('mass').value);
            const colors = unifiedField.getColorSchemes()[unifiedField.colorScheme];
            
            if (unifiedField.centralMass) {
                unifiedField.scene.remove(unifiedField.centralMass);
            }
            
            unifiedField.centralMass = new THREE.Group();
            
            // æ ¸å¿ƒé‡å­çƒä½“
            const coreGeometry = new THREE.SphereGeometry(0.4 * mass, 64, 64);
            const coreMaterial = new THREE.MeshPhysicalMaterial({ 
                color: colors.accent,
                emissive: new THREE.Color(colors.accent).multiplyScalar(0.4),
                metalness: 0.1,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.castShadow = true;
            unifiedField.centralMass.add(core);
            
            // å¤šå±‚èƒ½é‡åœºç¯ç³»ç»Ÿ
            for (let i = 1; i <= 5; i++) {
                const ringRadius = 0.5 + i * 0.4 * mass;
                const ringThickness = 0.02 * Math.sqrt(mass);
                
                const ringGeometry = new THREE.TorusGeometry(ringRadius, ringThickness, 16, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? colors.primary : colors.secondary,
                    transparent: true,
                    opacity: (0.6 / i) * (1 + 0.3 * Math.sin(unifiedField.time * (i + 1))),
                    blending: THREE.AdditiveBlending
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2 + (Math.PI / 12) * i;
                ring.rotation.y = (Math.PI / 6) * i;
                ring.userData.rotationSpeed = 0.008 * (i + 1);
                ring.userData.oscillationPhase = i * Math.PI / 3;
                unifiedField.centralMass.add(ring);
            }
            
            // é«˜çº§ç²’å­åœºç³»ç»Ÿ
            const particleCount = Math.floor(400 * mass * unifiedField.particleDensity);
            const particleGeometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const radius = 0.8 + Math.random() * 4;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                
                const color = new THREE.Color(colors.particle).multiplyScalar(0.8 + Math.random() * 0.4);
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
                
                sizes[i] = 0.06 + Math.random() * 0.04;
                
                velocities[i3] = direction[0];
                velocities[i3 + 1] = direction[1];
                velocities[i3 + 2] = direction[2];
                
                phases[i] = (i / particleCount) * Math.PI * 2;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            particleSystem.userData = {
                direction: direction,
                helixPoints: helixPoints,
                velocities: velocities,
                phases: phases,
                index: index,
                totalDirections: totalDirections
            };
            
            return particleSystem;
        }
        
        // === åŠ¨æ€åœºçº¿ç³»ç»Ÿ ===
        function createDynamicFieldLines(helixPoints, index, colors) {
            const fieldGeometry = new THREE.BufferGeometry();
            const fieldPositions = [];
            const fieldColors = [];
            
            // åˆ›å»ºåœºçº¿ç½‘æ ¼
            for (let i = 0; i < helixPoints.length; i += 10) {
                const point = helixPoints[i];
                const nextPoint = helixPoints[Math.min(i + 10, helixPoints.length - 1)];
                
                fieldPositions.push(point.x, point.y, point.z);
                fieldPositions.push(nextPoint.x, nextPoint.y, nextPoint.z);
                
                const intensity = Math.max(0.3, 1 - point.length() / 15);
                const color = new THREE.Color(colors.primary).multiplyScalar(intensity);
                
                fieldColors.push(color.r, color.g, color.b);
                fieldColors.push(color.r, color.g, color.b);
            }
            
            fieldGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fieldPositions, 3));
            fieldGeometry.setAttribute('color', new THREE.Float32BufferAttribute(fieldColors, 3));
            
            const fieldMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.LineSegments(fieldGeometry, fieldMaterial);
        }
        
        // === é«˜çº§å…‰ç…§ç³»ç»Ÿ ===
        function setupAdvancedLighting() {
            // æ¸…é™¤ç°æœ‰å…‰æº
            const lights = unifiedField.scene.children.filter(child => child.isLight);
            lights.forEach(light => unifiedField.scene.remove(light));
            
            const colors = unifiedField.getColorSchemes()[unifiedField.colorScheme];
            
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(colors.primary, 0.2);
            unifiedField.scene.add(ambientLight);
            
            // ä¸»æ–¹å‘å…‰
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
            mainLight.position.set(20, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.camera.near = 0.1;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -20;
            mainLight.shadow.camera.right = 20;
            mainLight.shadow.camera.top = 20;
            mainLight.shadow.camera.bottom = -20;
            unifiedField.scene.add(mainLight);
            
            // åŠ¨æ€ç‚¹å…‰æºç³»ç»Ÿ
            const pointLight1 = new THREE.PointLight(colors.primary, 2.0, 30);
            pointLight1.position.set(0, 0, 0);
            unifiedField.scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(colors.secondary, 1.5, 25);
            pointLight2.position.set(8, 8, 8);
            unifiedField.scene.add(pointLight2);
            
            const pointLight3 = new THREE.PointLight(colors.accent, 1.0, 20);
            pointLight3.position.set(-5, 5, -5);
            unifiedField.scene.add(pointLight3);
            
            // è¡¥å……å…‰æº
            const fillLight1 = new THREE.DirectionalLight(colors.secondary, 0.3);
            fillLight1.position.set(-15, -15, -10);
            unifiedField.scene.add(fillLight1);
            
            const fillLight2 = new THREE.DirectionalLight(colors.accent, 0.2);
            fillLight2.position.set(10, -10, 15);
            unifiedField.scene.add(fillLight2);
        }
        
        // === æ™ºèƒ½æ§åˆ¶ç³»ç»Ÿ ===
        function setupSmartControls() {
            // å‚æ•°æ»‘å—äº‹ä»¶
            const sliders = ['directions', 'omega', 'velocity', 'radius', 'mass', 'animSpeed', 'fieldDecay', 'particleDensity', 'cameraDistanceSlider'];
            
            sliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                if (slider) {
                    slider.addEventListener('input', handleSliderChange);
                    slider.addEventListener('change', handleSliderChange);
                }
            });
        }
        
        function handleSliderChange(event) {
            const sliderId = event.target.id;
            const value = parseFloat(event.target.value);
            
            // æ›´æ–°æ˜¾ç¤ºå€¼
            switch(sliderId) {
                case 'directions':
                    document.getElementById('directionCount').textContent = value;
                    createSuperiorSpatialSystem();
                    break;
                case 'omega':
                    document.getElementById('omegaValue').textContent = value.toFixed(1);
                    break;
                case 'velocity':
                    document.getElementById('velocityValue').textContent = value.toFixed(1) + 'c';
                    break;
                case 'radius':
                    document.getElementById('radiusValue').textContent = value.toFixed(1);
                    createSuperiorSpatialSystem();
                    break;
                case 'mass':
                    document.getElementById('massValue').textContent = value.toFixed(1);
                    createAdvancedCentralMass();
                    createSuperiorSpatialSystem();
                    break;
                case 'animSpeed':
                    unifiedField.animationSpeed = value;
                    document.getElementById('speedValue').textContent = value.toFixed(1) + 'x';
                    break;
                case 'fieldDecay':
                    unifiedField.fieldDecay = value;
                    document.getElementById('decayValue').textContent = value.toFixed(1);
                    break;
                case 'particleDensity':
                    unifiedField.particleDensity = value;
                    document.getElementById('densityValue').textContent = value.toFixed(1);
                    createSuperiorSpatialSystem();
                    break;
                case 'cameraDistanceSlider':
                    unifiedField.cameraDistance = value;
                    document.getElementById('cameraDistance').textContent = value.toFixed(1);
                    updateCameraDistance();
                    break;
            }
            
            updateProgressBar(event.target);
        }
        
        function updateProgressBar(slider) {
            const progress = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
            const progressRing = slider.parentElement.querySelector('.progress-ring');
            if (progressRing) {
                progressRing.style.setProperty('--progress', progress + '%');
            }
        }
        
        // === é«˜çº§äº¤äº’ç³»ç»Ÿ ===
        function setupAdvancedInteraction() {
            let mouseDown = false;
            let mouseDownX = 0, mouseDownY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            
            // é¼ æ ‡äº‹ä»¶
            unifiedField.renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseDownX = event.clientX;
                mouseDownY = event.clientY;
            });
            
            unifiedField.renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            unifiedField.renderer.domElement.addEventListener('mousemove', (event) => {
                unifiedField.mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                unifiedField.mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                
                if (mouseDown && unifiedField.cameraMode === 'free') {
                    const deltaX = event.clientX - mouseDownX;
                    const deltaY = event.clientY - mouseDownY;
                    
                    targetRotationY -= deltaX * 0.01;
                    targetRotationX -= deltaY * 0.01;
                    targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                    
                    const radius = unifiedField.cameraDistance;
                    unifiedField.camera.position.x = radius * Math.cos(targetRotationX) * Math.sin(targetRotationY);
                    unifiedField.camera.position.y = radius * Math.sin(targetRotationX);
                    unifiedField.camera.position.z = radius * Math.cos(targetRotationX) * Math.cos(targetRotationY);
                    unifiedField.camera.lookAt(0, 0, 0);
                    
                    mouseDownX = event.clientX;
                    mouseDownY = event.clientY;
                }
            });
            
            // æ»šè½®ç¼©æ”¾
            unifiedField.renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                unifiedField.cameraDistance = Math.max(3, Math.min(100, unifiedField.cameraDistance + event.deltaY * 0.01));
                document.getElementById('cameraDistance').textContent = unifiedField.cameraDistance.toFixed(1);
                updateCameraDistance();
            });
            
            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', handleKeyPress);
        }
        
        function handleKeyPress(event) {
            switch(event.key.toLowerCase()) {
                case ' ': event.preventDefault(); toggleAnimation(); break;
                case 'r': resetSimulation(); break;
                case 'v': toggleVectors(); break;
                case 't': toggleTrails(); break;
                case 'f': toggleFieldLines(); break;
                case 'c': cycleCameraMode(); break;
                case 's': captureFrame(); break;
                case 'h': toggleAllPanels(); break;
                case '1': loadPreset('default'); break;
                case '2': loadPreset('intense'); break;
                case '3': loadPreset('gentle'); break;
                case '4': loadPreset('spiral'); break;
                case '5': loadPreset('quantum'); break;
                case '6': loadPreset('cosmic'); break;
            }
        }
        
        // === æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ ===
        function animate() {
            // FPSç»Ÿè®¡
            unifiedField.frameCount++;
            const currentTime = performance.now();
            if (currentTime - unifiedField.lastTime >= 1000) {
                const fps = Math.round(unifiedField.frameCount * 1000 / (currentTime - unifiedField.lastTime));
                document.getElementById('fpsCounter').textContent = fps;
                unifiedField.fpsHistory.push(fps);
                if (unifiedField.fpsHistory.length > 10) unifiedField.fpsHistory.shift();
                
                unifiedField.frameCount = 0;
                unifiedField.lastTime = currentTime;
            }
            
            if (unifiedField.isAnimating) {
                unifiedField.time += 0.016 * unifiedField.animationSpeed;
                
                updateAdvancedCentralMass();
                updateIntelligentParticleSystems();
                updateSmartCamera();
                updateSystemStats();
                updateDynamicLighting();
            }
            
            unifiedField.renderer.render(unifiedField.scene, unifiedField.camera);
            requestAnimationFrame(animate);
        }
        
        // === é«˜çº§ä¸­å¿ƒè´¨é‡æ›´æ–° ===
        function updateAdvancedCentralMass() {
            if (!unifiedField.centralMass) return;
            
            const mass = parseFloat(document.getElementById('mass').value);
            
            // æ ¸å¿ƒé‡å­è„‰åŠ¨
            const core = unifiedField.centralMass.children[0];
            const pulseFactor = 1 + 0.15 * Math.sin(unifiedField.time * 4) + 0.05 * Math.sin(unifiedField.time * 8.7);
            core.scale.setScalar(pulseFactor);
            
            // æ•´ä½“æ—‹è½¬
            unifiedField.centralMass.rotation.y += 0.015 * unifiedField.animationSpeed;
            unifiedField.centralMass.rotation.z += 0.008 * unifiedField.animationSpeed;
            
            // èƒ½é‡ç¯æ™ºèƒ½æ—‹è½¬
            for (let i = 1; i < unifiedField.centralMass.children.length - 1; i++) {
                const ring = unifiedField.centralMass.children[i];
                if (ring.userData.rotationSpeed) {
                    ring.rotation.z += ring.userData.rotationSpeed * unifiedField.animationSpeed;
                    ring.rotation.x += ring.userData.rotationSpeed * 0.3 * unifiedField.animationSpeed;
                    
                    // åŠ¨æ€é€æ˜åº¦
                    const oscillation = Math.sin(unifiedField.time * 2 + ring.userData.oscillationPhase);
                    ring.material.opacity = (0.6 / i) * (1 + 0.4 * oscillation);
                }
            }
            
            // ç²’å­åœºåŠ¨ç”»
            const particleSystem = unifiedField.centralMass.children[unifiedField.centralMass.children.length - 1];
            if (particleSystem && particleSystem.geometry && particleSystem.userData.velocities) {
                const positions = particleSystem.geometry.attributes.position.array;
                const colors = particleSystem.geometry.attributes.color.array;
                const velocities = particleSystem.userData.velocities;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // æ›´æ–°ä½ç½®
                    positions[i] += velocities[i] * unifiedField.animationSpeed;
                    positions[i + 1] += velocities[i + 1] * unifiedField.animationSpeed;
                    positions[i + 2] += velocities[i + 2] * unifiedField.animationSpeed;
                    
                    // è¾¹ç•Œæ£€æµ‹å’Œé‡ç½®
                    const distance = Math.sqrt(positions[i]**2 + positions[i + 1]**2 + positions[i + 2]**2);
                    if (distance > 8) {
                        const resetRadius = 0.8 + Math.random() * 1.5;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        positions[i] = resetRadius * Math.sin(phi) * Math.cos(theta);
                        positions[i + 1] = resetRadius * Math.sin(phi) * Math.sin(theta);
                        positions[i + 2] = resetRadius * Math.cos(phi);
                    }
                    
                    // åŠ¨æ€é¢œè‰²
                    const intensity = Math.max(0.3, 1 - distance / 8);
                    const colorShift = unifiedField.time * 0.5 + i * 0.01;
                    const color = new THREE.Color().setHSL((colorShift % 1), 0.8, 0.6 * intensity);
                    
                    colors[i] = color.r;
                    colors[i + 1] = color.g;
                    colors[i + 2] = color.b;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.geometry.attributes.color.needsUpdate = true;
            }
        }
        
        // === æ™ºèƒ½ç²’å­ç³»ç»Ÿæ›´æ–° ===
        function updateIntelligentParticleSystems() {
            const velocity = parseFloat(document.getElementById('velocity').value);
            const omega = parseFloat(document.getElementById('omega').value);
            const radius = parseFloat(document.getElementById('radius').value);
            
            let totalParticles = 0;
            let totalFieldStrength = 0;
            let systemEnergy = 0;
            
            unifiedField.particleSystems.forEach((system, systemIndex) => {
                const positions = system.geometry.attributes.position.array;
                const colors = system.geometry.attributes.color.array;
                const sizes = system.geometry.attributes.size.array;
                const { direction, phases, index, totalDirections } = system.userData;
                
                const particleCount = positions.length / 3;
                totalParticles += particleCount;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const t = unifiedField.time * velocity + phases[i] + (i / particleCount) * 10;
                    
                    // é«˜çº§èºæ—‹å‚æ•°
                    const spiralT = t % 12;
                    const dynamicRadius = radius * (1 + 
                        0.25 * Math.sin(t * 1.2) + 
                        0.1 * Math.sin(t * 3.1 + index) +
                        0.05 * Math.cos(t * 5.7)
                    );
                    const theta = omega * t + index * Math.PI / 8;
                    const z = spiralT;
                    
                    // æ„å»ºå±€éƒ¨åæ ‡ç³»
                    const zAxis = new THREE.Vector3(...direction);
                    const xAxis = new THREE.Vector3();
                    const yAxis = new THREE.Vector3();
                    
                    if (Math.abs(zAxis.x) < 0.9) {
                        xAxis.crossVectors(zAxis, new THREE.Vector3(1, 0, 0)).normalize();
                    } else {
                        xAxis.crossVectors(zAxis, new THREE.Vector3(0, 1, 0)).normalize();
                    }
                    yAxis.crossVectors(zAxis, xAxis).normalize();
                    
                    // èºæ—‹ä½ç½®è®¡ç®—
                    const localX = dynamicRadius * Math.cos(theta);
                    const localY = dynamicRadius * Math.sin(theta);
                    
                    const globalPos = new THREE.Vector3();
                    globalPos.addScaledVector(xAxis, localX);
                    globalPos.addScaledVector(yAxis, localY);
                    globalPos.addScaledVector(zAxis, z);
                    
                    positions[i3] = globalPos.x;
                    positions[i3 + 1] = globalPos.y;
                    positions[i3 + 2] = globalPos.z;
                    
                    // æ™ºèƒ½é¢œè‰²å’Œå¼ºåº¦è®¡ç®—
                    const distance = globalPos.length();
                    const intensity = Math.max(0.2, Math.exp(-distance * unifiedField.fieldDecay / 15));
                    const hue = (index / totalDirections + unifiedField.time * 0.08 + distance * 0.02) % 1;
                    const saturation = 0.8 + 0.2 * Math.sin(unifiedField.time * 3 + i * 0.1);
                    const lightness = 0.6 + 0.3 * intensity;
                    
                    const color = new THREE.Color().setHSL(hue, saturation, lightness);
                    colors[i3] = color.r * intensity;
                    colors[i3 + 1] = color.g * intensity;
                    colors[i3 + 2] = color.b * intensity;
                    
                    // åŠ¨æ€å¤§å°
                    sizes[i] = (0.05 + 0.05 * Math.sin(unifiedField.time * 4 + i * 0.2)) * intensity;
                    
                    totalFieldStrength += intensity;
                    systemEnergy += intensity * distance;
                }
                
                system.geometry.attributes.position.needsUpdate = true;
                system.geometry.attributes.color.needsUpdate = true;
                system.geometry.attributes.size.needsUpdate = true;
            });
            
            // æ›´æ–°ç»Ÿè®¡æ•°æ®
            document.getElementById('particleCount').textContent = totalParticles;
            document.getElementById('fieldStrength').textContent = (totalFieldStrength / Math.max(totalParticles, 1)).toFixed(3);
            document.getElementById('systemEnergy').textContent = (systemEnergy / 1000).toFixed(2);
        }
        
        // === æ™ºèƒ½ç›¸æœºç³»ç»Ÿ ===
        function updateSmartCamera() {
            const cameraSpeed = 0.02 * unifiedField.animationSpeed;
            
            switch (unifiedField.cameraMode) {
                case 'orbit':
                    const orbitRadius = unifiedField.cameraDistance + 3 * Math.sin(unifiedField.time * 0.1);
                    unifiedField.camera.position.x = orbitRadius * Math.cos(unifiedField.time * cameraSpeed);
                    unifiedField.camera.position.z = orbitRadius * Math.sin(unifiedField.time * cameraSpeed);
                    unifiedField.camera.position.y = 8 + 5 * Math.sin(unifiedField.time * 0.03);
                    unifiedField.camera.lookAt(unifiedField.cameraTarget);
                    break;
                    
                case 'follow':
                    if (unifiedField.particleSystems.length > 0) {
                        const firstSystem = unifiedField.particleSystems[0];
                        const positions = firstSystem.geometry.attributes.position.array;
                        if (positions.length >= 3) {
                            const targetPos = new THREE.Vector3(positions[0], positions[1], positions[2]);
                            const cameraOffset = new THREE.Vector3(8, 6, 8);
                            unifiedField.camera.position.copy(targetPos).add(cameraOffset);
                            unifiedField.camera.lookAt(targetPos);
                        }
                    }
                    break;
                    
                case 'cinematic':
                    const cinematicRadius = unifiedField.cameraDistance;
                    const cinematicAngle = unifiedField.time * 0.01;
                    const elevation = 10 * Math.sin(unifiedField.time * 0.005) + 5;
                    
                    unifiedField.camera.position.x = cinematicRadius * Math.cos(cinematicAngle);
                    unifiedField.camera.position.y = elevation;
                    unifiedField.camera.position.z = cinematicRadius * Math.sin(cinematicAngle);
                    unifiedField.camera.lookAt(unifiedField.cameraTarget);
                    break;
                    
                case 'free':
                    // ç”¨æˆ·æ§åˆ¶ï¼Œä¸éœ€è¦è‡ªåŠ¨æ›´æ–°
                    break;
            }
        }
        
        // === åŠ¨æ€å…‰ç…§æ›´æ–° ===
        function updateDynamicLighting() {
            const lights = unifiedField.scene.children.filter(child => child.isLight);
            
            lights.forEach((light, index) => {
                if (light.isPointLight) {
                    const phase = unifiedField.time * 0.5 + index * Math.PI;
                    light.intensity = light.userData?.baseIntensity || 1.5;
                    light.intensity *= (1 + 0.3 * Math.sin(phase));
                    
                    if (index === 1) {
                        light.position.x = 8 * Math.cos(unifiedField.time * 0.02);
                        light.position.z = 8 * Math.sin(unifiedField.time * 0.02);
                    }
                }
            });
        }
        
        // === ç³»ç»ŸçŠ¶æ€æ›´æ–° ===
        function updateSystemStats() {
            document.getElementById('timeValue').textContent = unifiedField.time.toFixed(2) + 's';
            
            // è®¡ç®—ç©ºé—´æ›²ç‡
            const mass = parseFloat(document.getElementById('mass').value);
            const curvature = Math.abs(Math.sin(unifiedField.time * 0.3)) * mass * 0.8;
            document.getElementById('curvature').textContent = curvature.toFixed(3);
            
            // è®¡ç®—åœºç›¸å¹²æ€§
            const coherence = Math.max(0.3, 0.85 + 0.15 * Math.sin(unifiedField.time * 0.1));
            document.getElementById('coherence').textContent = coherence.toFixed(2);
            
            // ç³»ç»ŸçŠ¶æ€
            const avgFPS = unifiedField.fpsHistory.reduce((a, b) => a + b, 0) / Math.max(unifiedField.fpsHistory.length, 1);
            let statusText = 'ğŸŸ¢ è¿è¡Œæ­£å¸¸';
            let statusColor = '#00ff88';
            
            if (avgFPS < 30) {
                statusText = 'ğŸŸ¡ æ€§èƒ½è­¦å‘Š';
                statusColor = '#ffaa00';
            }
            if (avgFPS < 15) {
                statusText = 'ğŸ”´ æ€§èƒ½ä¸ä½³';
                statusColor = '#ff4444';
            }
            
            const statusElement = document.getElementById('systemStatus');
            statusElement.textContent = statusText;
            statusElement.style.color = statusColor;
            
            // å†…å­˜å’ŒGPUçŠ¶æ€
            document.getElementById('memoryUsage').textContent = unifiedField.particleSystems.length > 20 ? 'é«˜' : 'æ­£å¸¸';
            document.getElementById('gpuUsage').textContent = avgFPS > 45 ? 'ä¼˜åŒ–' : 'ç¹å¿™';
            document.getElementById('meshComplexity').textContent = unifiedField.spiralGroups.length > 15 ? 'é«˜' : 'ä¸­ç­‰';
        }
        
        // === å®ç”¨åŠŸèƒ½å‡½æ•° ===
        function clearExistingSystems() {
            unifiedField.spiralGroups.forEach(group => unifiedField.scene.remove(group));
            unifiedField.particleSystems.forEach(system => unifiedField.scene.remove(system));
            unifiedField.fieldLines.forEach(line => unifiedField.scene.remove(line));
            unifiedField.trailSystems.forEach(trail => unifiedField.scene.remove(trail));
            
            unifiedField.spiralGroups = [];
            unifiedField.particleSystems = [];
            unifiedField.fieldLines = [];
            unifiedField.trailSystems = [];
        }
        
        function updateCameraDistance() {
            if (unifiedField.cameraMode === 'orbit' || unifiedField.cameraMode === 'cinematic') {
                const currentPos = unifiedField.camera.position;
                const currentDistance = currentPos.length();
                const scaleFactor = unifiedField.cameraDistance / currentDistance;
                unifiedField.camera.position.multiplyScalar(scaleFactor);
            }
        }
        
        // === ç”¨æˆ·äº¤äº’å‡½æ•° ===
        function toggleAnimation() {
            unifiedField.isAnimating = !unifiedField.isAnimating;
            const btn = document.getElementById('playPauseBtn');
            btn.textContent = unifiedField.isAnimating ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ ç»§ç»­';
            btn.classList.toggle('active', !unifiedField.isAnimating);
        }
        
        function resetSimulation() {
            unifiedField.time = 0;
            createAdvancedCentralMass();
            createSuperiorSpatialSystem();
            console.log('ğŸ”„ ç³»ç»Ÿå·²é‡ç½®');
        }
        
        function stepAnimation() {
            if (!unifiedField.isAnimating) {
                unifiedField.time += 0.016;
                updateAdvancedCentralMass();
                updateIntelligentParticleSystems();
                updateSystemStats();
            }
        }
        
        function toggleVectors() {
            unifiedField.showVectors = !unifiedField.showVectors;
            const btn = document.getElementById('vectorBtn');
            btn.classList.toggle('active', unifiedField.showVectors);
            // å®ç°çŸ¢é‡åœºæ˜¾ç¤ºé€»è¾‘
        }
        
        function toggleTrails() {
            unifiedField.showTrails = !unifiedField.showTrails;
            const btn = document.getElementById('trailBtn');
            btn.classList.toggle('active', unifiedField.showTrails);
            createSuperiorSpatialSystem();
        }
        
        function toggleFieldLines() {
            unifiedField.showFieldLines = !unifiedField.showFieldLines;
            const btn = document.getElementById('fieldBtn');
            btn.classList.toggle('active', unifiedField.showFieldLines);
            createSuperiorSpatialSystem();
        }
        
        function cycleCameraMode() {
            const modes = ['orbit', 'follow', 'cinematic', 'free'];
            const currentIndex = modes.indexOf(unifiedField.cameraMode);
            unifiedField.cameraMode = modes[(currentIndex + 1) % modes.length];
            
            const btn = document.getElementById('cameraBtn');
            const modeNames = { orbit: 'è½¨é“', follow: 'è·Ÿéš', cinematic: 'ç”µå½±', free: 'è‡ªç”±' };
            btn.textContent = `ğŸ“¹ ${modeNames[unifiedField.cameraMode]}æ¨¡å¼`;
            
            console.log(`ğŸ“¹ ç›¸æœºæ¨¡å¼: ${unifiedField.cameraMode}`);
        }
        
        function resetCamera() {
            unifiedField.cameraDistance = 15;
            unifiedField.camera.position.set(15, 10, 15);
            unifiedField.camera.lookAt(0, 0, 0);
            document.getElementById('cameraDistance').textContent = '15.0';
        }
        
        function autoFocus() {
            if (unifiedField.centralMass) {
                unifiedField.cameraTarget.copy(unifiedField.centralMass.position);
                unifie[i] = 0.03 + Math.random() * 0.07;
                
                // éšæœºé€Ÿåº¦
                velocities[i * 3] = (Math.random() - 0.5) * 0.02;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            particles.userData = { velocities: velocities };
            unifiedField.centralMass.add(particles);
            
            unifiedField.scene.add(unifiedField.centralMass);
        }
        
        // === è¶…çº§ç©ºé—´ç³»ç»Ÿ ===
        function createSuperiorSpatialSystem() {
            console.log('ğŸŒŒ åˆ›å»ºè¶…çº§ç©ºé—´å‘æ•£ç³»ç»Ÿ...');
            
            // æ¸…ç†ç°æœ‰ç³»ç»Ÿ
            clearExistingSystems();
            
            const directionCount = parseInt(document.getElementById('directions').value);
            const directions = generateOptimizedDirections(directionCount);
            const radius = parseFloat(document.getElementById('radius').value);
            const mass = parseFloat(document.getElementById('mass').value);
            const colors = unifiedField.getColorSchemes()[unifiedField.colorScheme];
            
            directions.forEach((direction, index) => {
                createAdvancedSpiralSystem(direction, index, directions.length, radius, mass, colors);
            });
            
            document.getElementById('activeDirections').textContent = directionCount;
        }
        
        function createAdvancedSpiralSystem(direction, index, totalDirections, radius, mass, colors) {
            const spiralGroup = new THREE.Group();
            
            // æ„å»ºé«˜ç²¾åº¦èºæ—‹è½¨è¿¹
            const helixPoints = generateHighPrecisionHelix(direction, radius, index);
            
            // åˆ›å»ºåŠ¨æ€æ¸å˜èºæ—‹è½¨è¿¹
            const helixGeometry = createAdvancedHelixGeometry(helixPoints, index, totalDirections);
            const helixMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                linewidth: 3
            });
            
            const helixLine = new THREE.LineSegments(helixGeometry, helixMaterial);
            spiralGroup.add(helixLine);
            
            // åˆ›å»ºæ™ºèƒ½ç²’å­ç³»ç»Ÿ
            const particleSystem = createIntelligentParticleSystem(direction, helixPoints, index, totalDirections, mass, colors);
            spiralGroup.add(particleSystem);
            unifiedField.particleSystems.push(particleSystem);
            
            // æ·»åŠ åœºçº¿æ•ˆæœ
            if (unifiedField.showFieldLines) {
                const fieldLines = createDynamicFieldLines(helixPoints, index, colors);
                spiralGroup.add(fieldLines);
                unifiedField.fieldLines.push(fieldLines);
            }
            
            unifiedField.scene.add(spiralGroup);
            unifiedField.spiralGroups.push(spiralGroup);
        }
        
        // === é«˜ç²¾åº¦èºæ—‹ç”Ÿæˆ ===
        function generateHighPrecisionHelix(direction, radius, index) {
            const points = [];
            const numPoints = 500; // æ›´é«˜ç²¾åº¦
            const maxDistance = 15;
            const omega = parseFloat(document.getElementById('omega').value);
            
            // æ„å»ºæ­£äº¤åæ ‡ç³»
            const zAxis = new THREE.Vector3(...direction);
            const xAxis = new THREE.Vector3();
            const yAxis = new THREE.Vector3();
            
            if (Math.abs(zAxis.x) < 0.9) {
                xAxis.crossVectors(zAxis, new THREE.Vector3(1, 0, 0)).normalize();
            } else {
                xAxis.crossVectors(zAxis, new THREE.Vector3(0, 1, 0)).normalize();
            }
            yAxis.crossVectors(zAxis, xAxis).normalize();
            
            // ç”Ÿæˆé«˜ç²¾åº¦èºæ—‹ç‚¹
            for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * maxDistance;
                
                // åŠ¨æ€åŠå¾„ï¼ˆæ›´å¤æ‚çš„å˜åŒ–ï¼‰
                const dynamicRadius = radius * (1 + 
                    0.2 * Math.sin(t * 0.8) + 
                    0.1 * Math.sin(t * 2.3 + index) +
                    0.05 * Math.sin(t * 4.7)
                );
                
                // èºæ—‹å‚æ•°
                const theta = omega * t + index * Math.PI / 6;
                const z = t;
                
                // å±€éƒ¨åæ ‡
                const localX = dynamicRadius * Math.cos(theta);
                const localY = dynamicRadius * Math.sin(theta);
                
                // è½¬æ¢åˆ°å…¨å±€åæ ‡
                const point = new THREE.Vector3();
                point.addScaledVector(xAxis, localX);
                point.addScaledVector(yAxis, localY);
                point.addScaledVector(zAxis, z);
                
                points.push(point);
            }
            
            return points;
        }
        
        // === é«˜çº§èºæ—‹å‡ ä½•åˆ›å»º ===
        function createAdvancedHelixGeometry(points, index, totalDirections) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < points.length - 1; i++) {
                const progress = i / points.length;
                
                // åŠ¨æ€é¢œè‰²è®¡ç®—
                const hue1 = (index / totalDirections + progress * 0.4 + unifiedField.time * 0.05) % 1;
                const hue2 = (index / totalDirections + (progress + 0.005) * 0.4 + unifiedField.time * 0.05) % 1;
                
                const saturation = 0.8 + 0.2 * Math.sin(progress * Math.PI * 4);
                const lightness = 0.5 + 0.3 * Math.sin(progress * Math.PI * 2);
                
                const color1 = new THREE.Color().setHSL(hue1, saturation, lightness);
                const color2 = new THREE.Color().setHSL(hue2, saturation, lightness);
                
                // æ·»åŠ çº¿æ®µ
                positions.push(points[i].x, points[i].y, points[i].z);
                positions.push(points[i + 1].x, points[i + 1].y, points[i + 1].z);
                
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            return geometry;
        }
        
        // === æ™ºèƒ½ç²’å­ç³»ç»Ÿ ===
        function createIntelligentParticleSystem(direction, helixPoints, index, totalDirections, mass, colors) {
            const particleCount = Math.floor(30 * mass * unifiedField.particleDensity);
            const geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);
            const phases = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                positions[i3] = 0;
                positions[i3 + 1] = 0;
                positions[i3 + 2] = 0;
                
                const baseColor = new THREE.Color().setHSL((index / totalDirections), 0.8, 0.7);
                particleColors[i3] = baseColor.r;
                particleColors[i3 + 1] = baseColor.g;
                particleColors[i3 + 2] = baseColor.b;
                
                sizes